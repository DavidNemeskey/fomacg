#ifndef RULE_CONDITION_TREE_H
#define RULE_CONDITION_TREE_H

/**
 * This file specifies the "rule condition tree" generated by fomacg and used
 * by fomacg_proc to cut down on the number of FSA tests agains the input
 * sentence.
 *
 * Effectively, the rule condition tree is a binary tree, where each node stores
 * a minimal, deterministic and epsilon-free FSA that is used to test the input
 * sentence. The leaf nodes have rules associated with them, and if the FSA
 * accepts the sentence, it means that the rule can be applied to it.
 * Intermediate nodes contain FSAs that are the unions of their children, and
 * test for both of their rule conditions. This structure enables us to find a
 * rule that can be applied to the input sentence in O(ln(G)), instead of the
 * O(G) of a linear search.
 *
 * Note however, that since the deterministic union automaton of two FSAs may
 * be of exponential size, it is highly unlikely that we can put all the rules
 * in a section of a CG grammar in one tree. The number of nodes in the tree
 * will thus peak at 6-8. However, in that case, it might be easier on the
 * memory (and perhaps not too heavier on the CPU) to have a "flat" tree: one
 * that consists of only leaves and the root node.
 */

// TODO: flat tree
// TOOO: test transducers?

#ifndef MAX_STATES
#define MAX_STATES 1000
#endif

#ifndef FOMA_INCLUDED
#define FOMA_INCLUDED
#include <stdbool.h>  // to avoid errors in fomalib.h
#include <fomalib.h>
#endif

#include <vector>

#include "fomacg_common.h"
#include "fomacg_types.h"

/** A node in the tree. */
struct Node {
  int section;
  /** The number of rules this tree covers. */
  size_t no_rules;
  /** The condition FSA. */
  FstPair fsa;
  /** The rule FST. */
  FstPair fst;
  struct Node* left;
  struct Node* right;
  /** The next group of tests on the same level as this one. */
  struct Node* next;
};

/** Frees the memory associated with the specified Node forest. */
void free_nodes(Node* node);

/** The sorting order for rules and trees. */
enum SortOrder {
  SORT_NAME,
  SORT_SIZE
};

/** The ancestor of all classes the merge conditions. */
class ConditionMerger {
public:
  ConditionMerger(SortOrder order=SORT_SIZE);
  /**
   * Serializes @p tree. Called by fomacg when it writes the rules to file.
   *
   * @note The signature is subject to change in case we decide to support
   *       non-tree-based mergers.
   * @param[in] tree the tree to serialize.
   * @param[out] num_rules the number of rules in @p tree.
   * @return an array of <tt>struct fsm*</tt>s. The order will be the one
   *         described for deserialize_tree().
   */
  virtual struct fsm** serialize(struct Node* tree, size_t* num_rules)=0;

  /**
   * Given an array of FSTs read from a .fst file, it creates the binary trees
   * they were created from.
   *
   * The FSTs must have been saved by the current ConditionMerger subclass.
   *
   * @note Same as for serialize().
   */
  virtual struct Node* deserialize(const FstVector& rules)=0;

  /**
   * Merges the conditions it can and returns the resulting tree. Sets the
   * pointers to the machines in @p cg_rules to NULL.
   */
  virtual struct Node* merge(struct cg_rules* cg_rules, size_t num_rules)=0;

protected:
  /**
   * Comparison function for sort() that sorts the rules first by section, then
   * by size.
   */
  static bool rule_statecount_compare(const struct cg_rules* rule1,
                                      const struct cg_rules* rule2);
  /**
   * Comparison function for sort() that sorts the rules first by section, then
   * by name.
   */
  static bool rule_name_compare(const struct cg_rules* rule1,
                                const struct cg_rules* rule2);

  /** Unions the two FSTs. */
  struct fsm* union_trees(struct fsm* fst1, struct fsm* fst2);

  /** The sorting order. */
  SortOrder order;
};

/** A merger that returns binary trees. */
class TreeConditionMerger : public ConditionMerger {
public:
  TreeConditionMerger(SortOrder order=SORT_SIZE);
  /**
   * The FSTs are in prefix order (root, left, leftleft, ..., leftright, ...,
   * right, ...). The intermediate nodes (whose name does not start with "R" or
   * "C") are represented by their condition FSA; leaf nodes are by both the
   * FSA and the rule FST.
   */
  struct fsm** serialize(struct Node* tree, size_t* num_rules);
  struct Node* deserialize(const FstVector& rules);
  struct Node* merge(struct cg_rules* cg_rules, size_t num_rules);

protected:
  /**
   * Builds the binary tree(s) for the current section. It's up to the
   * sub-classes to specify how the trees are built.
   *
   * @param rules the rules array.
   * @paran begin the index of the first rule in the section.
   * @param length the length of the section.
   * @return the tree.
   */
  virtual struct Node* build_section_tree(std::vector<struct cg_rules* >& rules,
                                          size_t begin, size_t length)=0;

  /** Comparison function for sort() that sorts the tree(-node)s by size. */
  static bool tree_compare_size(
      const struct Node* tree1, const struct Node* tree2);

private:
  /**
   * Recursive function that counts the non-NULL struct fsm*'s in @p tree.
   * Called by serialize().
   * @note @p count is for inner use; when you call this function, it should be
   * @c 0 (the default).
   */
  size_t count_fsms(struct Node* tree, size_t count=0);
  /**
   * Recursive function that fills @p rules with the rules and conditions in
   * @p tree. Called by serialize().
   * @note @p i is for inner bookkeeping; when you call this function, it should
   * be @c 0 (the default).
   */
  size_t fill_fsms(struct Node* tree, struct fsm** rules, size_t i=0);

  /**
   * The recursive function that walks through @p rules and builds trees from
   * it. Called by deserialize().
   *
   * @param rules the rule fsm array.
   * @param index the current index in @p rules.
   */
  struct Node* array_to_tree(const FstVector& rules, size_t* index);

  /**
   * Called by merge() to add the newly created tree group @p trees to the
   * returned set (which starts at @p ret and ends in @p last). Updates the
   * latter two.
   */
  void add_trees_to_ret(struct Node* trees,
                        struct Node** ret, struct Node** last);
};

/**
 * Creates the trees by always merging the two smallest conditions (in terms of
 * state count).
 */
class SmallestFirstTreeMerger : public TreeConditionMerger {
public:
  /**
   * Constructor.
   * @param max_states if a condition has more states than this, it is not
   *                    considered for merging.
   */
  SmallestFirstTreeMerger(int max_states=MAX_STATES);

protected:
  struct Node* build_section_tree(std::vector<struct cg_rules*>& rules,
                                  size_t begin, size_t length);

private:
  int max_states;
};

/**
 * Creates trees of a previously fixed level.
 *
 * @warning Be careful and do not set the number of levels too high (>3 ...), or
 *          the <tt>fsm_union()</tt> operation may freeze your machine.
 */
class FixLevelTreeMerger : public TreeConditionMerger {
public:
  /**
   * Constructor.
   * @param levels the height of the trees. The default is three.
   */
  FixLevelTreeMerger(int levels=3);

protected:
  struct Node* build_section_tree(std::vector<struct cg_rules*>& rules,
                                  size_t begin, size_t length);

private:
  int levels;
};

/**
 * Sorts rules by their name and creates trees of a previously fixed level.
 *
 * @warning Be careful and do not set the number of levels too high (>3 ...), or
 *          the <tt>fsm_union()</tt> operation may freeze your machine.
 */
class SortedFixLevelTreeMerger : public TreeConditionMerger {
public:
  /**
   * Constructor.
   * @param levels the height of the trees. The default is three.
   */
  SortedFixLevelTreeMerger(int levels=3);

protected:
  struct Node* build_section_tree(std::vector<struct cg_rules*>& rules,
                                  size_t begin, size_t length);

private:
  int levels;
};

#endif
