#ifndef RULE_CONDITION_TREE_H
#define RULE_CONDITION_TREE_H

/**
 * This file specifies the "rule condition tree" generated by fomacg and used
 * by fomacg_proc to cut down on the number of FSA tests agains the input
 * sentence.
 *
 * Effectively, the rule condition tree is a binary tree, where each node stores
 * a minimal, deterministic and epsilon-free FSA that is used to test the input
 * sentence. The leaf nodes have rules associated with them, and if the FSA
 * accepts the sentence, it means that the rule can be applied to it.
 * Intermediate nodes contain FSAs that are the unions of their children, and
 * test for both of their rule conditions. This structure enables us to find a
 * rule that can be applied to the input sentence in O(ln(G)), instead of the
 * O(G) of a linear search.
 *
 * Note however, that since the deterministic union automaton of two FSAs may
 * be of exponential size, it is highly unlikely that we can put all the rules
 * in a section of a CG grammar in one tree. The number of nodes in the tree
 * will thus peak at 6-8. However, in that case, it might be easier on the
 * memory (and perhaps not too heavier on the CPU) to have a "flat" tree: one
 * that consists of only leaves and the root node.
 */

// TODO: flat tree
// TOOO: test transducers?

#ifndef FOMA_INCLUDED
#define FOMA_INCLUDED
#include <stdbool.h>  // to avoid errors in fomalib.h
#include <fomalib.h>
#endif

#include "fomacg_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/** A node in the tree. */
struct Node {
  int section;
  /** The number of rules this tree covers. */
  size_t no_rules;
  /** The condition FSA. */
  struct fsm* fsa;
  /** The rule FST. */
  struct fsm* fst;
  struct Node* left;
  struct Node* right;
  /** The next group of tests on the same level as this one. */
  struct Node* next;
};

/**
 * Serializes @p tree.
 *
 * @param[in] tree the tree to serialize.
 * @param[out] num_rules the number of rules in @p tree.
 * @return an array of <tt>struct fsm*</tt>s. The order will be the one
 *         described for deserialize_tree().
 */
struct fsm** serialize_tree(struct Node* tree, size_t* num_rules);
/**
 * Given an array of FSTs read from a .fst file, it creates the binary trees
 * they were created from.
 *
 * The FSTs must be in prefix order (root, left, leftleft, ..., leftright, ...,
 * right, ...). The intermediate nodes (whose name does not start with "R" or
 * "C") are represented by their condition FSA; leaf nodes are by both the
 * FSA and the rule FST.
 */
struct Node* deserialize_tree(struct fsm* rules[], size_t num_rules);

struct Node* create_binary_tree(struct cg_rules* cg_rules, size_t num_rules);

#ifdef __cplusplus
}
#endif

#endif
